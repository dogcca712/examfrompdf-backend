# 阶段1实现总结：任务队列和并发控制

## 已实现功能

### 1. 并发限制（Semaphore）
- ✅ 使用 `threading.Semaphore` 限制同时处理的任务数
- ✅ 默认最大并发数：5（可通过环境变量 `MAX_CONCURRENT_JOBS` 配置）
- ✅ 防止服务器过载和崩溃

### 2. 任务队列
- ✅ 使用 `queue.Queue` 实现任务排队
- ✅ 任务按顺序执行，但最多同时处理 N 个
- ✅ 防止任务丢失（即使服务器重启，任务状态在数据库中）

### 3. 工作线程
- ✅ 单工作线程从队列中取任务
- ✅ 使用 Semaphore 控制并发执行
- ✅ 自动处理任务完成和失败

### 4. 队列监控
- ✅ 实时统计队列状态
- ✅ 记录历史最高值
- ✅ API 端点：`GET /queue/status`

## API 端点

### GET /queue/status
获取任务队列状态（需要认证）

**响应格式：**
```json
{
  "queue_size": 5,           // 当前排队数
  "max_queue_size": 20,      // 历史最高排队数 ⭐
  "processing": 3,            // 当前正在处理数
  "max_processing": 5,       // 历史最高同时处理数 ⭐
  "max_concurrent": 5,        // 最大并发数
  "total_processed": 100,    // 总处理数
  "total_failed": 2,          // 总失败数
  "estimated_wait_time": 120 // 预估等待时间（秒）
}
```

**关键指标：**
- `max_queue_size`: 历史最高排队数（回答你的问题：是的，有这个功能！）
- `max_processing`: 历史最高同时处理数

## 工作原理

### 任务流程
1. 用户上传 PDF → `/generate` 端点
2. 任务加入队列 → `job_queue.put()`
3. 工作线程从队列取任务 → `job_queue.get()`
4. 获取信号量（如果已达最大并发，会阻塞等待）
5. 执行任务 → `run_job()`
6. 释放信号量，允许下一个任务开始

### 并发控制
```
假设 MAX_CONCURRENT_JOBS = 5

100个请求同时到达：
├─ 5个任务立即开始处理（获取到信号量）
├─ 95个任务在队列中等待
└─ 当有任务完成，队列中的下一个任务自动开始

结果：
- 最多5个任务同时运行
- 其他任务排队等待
- 服务器不会崩溃
```

## 配置

### 环境变量
```bash
# 设置最大并发数（默认5）
export MAX_CONCURRENT_JOBS=10
```

### 调整建议
- **低负载**：3-5个并发
- **中等负载**：5-10个并发
- **高负载**：10-20个并发（但建议迁移到 Celery）

## 监控功能

### 实时监控
- 当前排队数
- 当前处理数
- 预估等待时间

### 历史统计
- 历史最高排队数（回答你的问题）
- 历史最高同时处理数
- 总处理数
- 总失败数

## 优势

1. **防止服务器崩溃**
   - 限制并发数，防止资源耗尽
   - 任务排队，不会丢失

2. **可监控**
   - 实时查看队列状态
   - 历史统计数据

3. **可配置**
   - 通过环境变量调整并发数
   - 无需修改代码

4. **向后兼容**
   - 不影响现有功能
   - 任务状态仍在数据库中

## 限制

1. **内存队列**
   - 服务器重启后，队列中的任务会丢失
   - 但任务状态在数据库中，可以恢复

2. **单服务器**
   - 无法跨服务器共享队列
   - 如需多服务器，需要 Celery

3. **无持久化**
   - 队列统计在内存中
   - 服务器重启后重置

## 下一步

### 如果并发经常 > 10
- 考虑迁移到 Celery + Redis
- 支持分布式部署
- 任务持久化

### 如果并发 < 5
- 当前方案足够
- 可以优化监控和日志

## 测试建议

1. **测试并发限制**
   ```bash
   # 同时发送10个请求
   for i in {1..10}; do
     curl -X POST .../generate &
   done
   # 应该只有5个同时处理，其他排队
   ```

2. **测试监控**
   ```bash
   curl -H "Authorization: Bearer TOKEN" .../queue/status
   # 查看队列状态
   ```

3. **观察日志**
   ```bash
   journalctl -u examgen -f | grep "Queue size"
   # 观察队列大小变化
   ```

